########################################################################################################################
# Explain Type连接类型分析:
    https://www.cnblogs.com/zhijianliutang/p/4731307.html
    https://blog.csdn.net/weixin_31953847/article/details/113130279?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&spm=1001.2101.3001.4242
    https://class.imooc.com/lesson/1260#mid=36669
=》 结论: 12个
1) 性能从好到差: system > const > eq_ref > ref > fulltext > ref_or_null > index_range > unique_subquery > index_subquery > range > index > all
2) 尽量控制在ref以上(一般是在range之上): system > const > eq_ref > ref > range > index > all

########################################################################################################################
# 1、system: 表只有一行数据, 相当于系统表 => system是const类型的特例
    1) 数据准备:
CREATE TABLE `news` (
  `id`    int(10) UNSIGNED NOT NULL AUTO_INCREMENT,
  `title` varchar(255)     NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE = MyISAM DEFAULT CHARSET = utf8;
INSERT INTO `news` (`id`, `title`) VALUES (1, 'test');
    2) EXPLAIN查询:
EXPLAIN
SELECT * FROM news WHERE id = 1;
    3)                  type
1	SIMPLE	news		system	PRIMARY				1	100
    4) 测试结果 =>
        一、对于表中只有一条数据的, 无论是否使用了索引字段或者使用任何查询条件, 都是system连接类型
########################################################################################################################

########################################################################################################################
# 2、const: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据 => const查询速度非常快, 因为它仅仅读取一次即可
    1) 数据准备(再插入一条数据):
INSERT INTO `news` (`id`, `title`) VALUES (NULL, 'test1');
    2) EXPLAIN查询:
EXPLAIN
SELECT * FROM news WHERE id = 1;
    3)                  type
1	SIMPLE	news		const	PRIMARY	PRIMARY	4	const	1	100
    4) 测试结果 =>
        一、对于表中大于一条数据的, 如果使用了主键或唯一索引的字段, 且做了等值查询(这时肯定只有一条结果), 那么则是const连接类型
        二、对于表中大于一条数据的, 如果使用了主键或唯一索引的字段, 但做的是范围查询, 那么则是range连接类型(警惕!)
        三、对于表中大于一条数据的, 如果使用了其他字段, 无论做的是什么查询, 都是all连接类型(警惕!)
########################################################################################################################

########################################################################################################################
# 3、eq_ref: 多表关联时, 当组成部分使用了索引, 并且索引是主键或者唯一索引时出现 => 性能仅次于system和const
    1) 数据准备:
CREATE TABLE `content` (
  `id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT,
  `news_id` int(10) UNSIGNED NOT NULL,
  `content` text NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
INSERT INTO `content` (`id`, `news_id`, `content`) VALUES (NULL, '1', 'content');
INSERT INTO `content` (`id`, `news_id`, `content`) VALUES (NULL, '2', 'content2');
    2) EXPLAIN查询:
EXPLAIN
SELECT * FROM `news` JOIN `content` ON news.id = content.news_id
    3)                  type(这里content是小表, eq_ref是大表)
1	SIMPLE	content		ALL					3	100
1	SIMPLE	news		eq_ref	PRIMARY	PRIMARY	4	my_test.content.news_id	1	100
    4) 测试结果:
        一、多表关联时, 如果有一方用了主键或唯一索引的字段, 这时用的一方为eq_ref, 不用的一方为ALL
        一、多表关联时, 如果有两方都用了主键或唯一索引的字段, 这时MySQL会根据数据量做优化: 大表的一方为eq_ref, 小表的一方为ALL
########################################################################################################################

########################################################################################################################
# 4、ref: 当使用了联合索引, 且索引满足最左前缀规则(即索引既不是主键也不是唯一索引)时才会发生 => 如果这时只会匹配到少量的行, 那性能也还是不错的, 如果不匹配会变成全表扫描, 因为找不到数据, 注意数据类型要一致才为ref, 否则可能会为all
    1) 数据准备:
ALTER TABLE `news` ADD INDEX(`title`);
    2) EXPLAIN查询:
EXPLAIN
SELECT * FROM news where title = 'test';
    3)                  type
1	SIMPLE	news		ref	title	title	767	const	1	100
    4) 测试结果:
        一、使用索引满足最左前缀规则时, 当做单表查询时, 则类型为ref
        二、使用索引满足最左前缀规则时, 当做多表查询时, 那么本方为ref, 另一方根据情况决定: 可能为all | eq_ref | ref | const等
    5) 测试左前缀匹配原则:
        => 联合索引: content_news_id_content_msg_pk
        => 测试结果：对于news_id、content、msg字段位置可以随便都能匹配联合索引, 但是如果缺失了第一个字段(第二个可以缺), 那么后面的字段肯定走不了联合索引
        => 结论: 联合索引MySQL底层是从左到右存储在B+树的
########################################################################################################################

########################################################################################################################
# 5、fulltext: 全文索引 => 只有MyISAM存储引擎支持, 且字段要为CHAR、VARCHAR或TEXT类型
    1) MySQL索引类型详解: http://c.biancheng.net/view/7897.html
        一、按照存储方式分:
            1) B树索引: 大部分的索引, 叶子结点指向表的每一行, 可进行全键值、键值范围、键值前缀查询, 也可以对结果进行排序
            2) 哈希索引: 在MySQL的MEMORY存储引擎和HEAP 存储引擎中支持, 基于读取表中索引列的指来参与散列计算实现, 只支持=、IN()、<=>, 不支持键值的一部分去匹配(因为是全量计算散列)
        二、按逻辑区分：
            1) 普通索引: CREATE INDEX index_id ON tb_student(id); => 可插入重复值和空值
            2) 唯一索引: CREATE UNIQUE INDEX index_id ON tb_student(id); => 允许有空值, 但不允许有重复值
            3) 主键索引：使用PRIMARY KEY关键字标记, 不能使用CREATE INDEX创建 => 是一种特殊的唯一索引, 不允许有空值, 不允许有重复值
            4) 空间索引: CREATE SPATIAL INDEX index_line ON tb_student(line); => 只有MyISAM存储引擎支持, 且字段要为GEOMETRY类型
            5) 全文索引：CREATE FULLTEXT INDEX index_info ON tb_student(info); => 只有MyISAM存储引擎支持, 且字段要为CHAR、VARCHAR或TEXT类型
        三、按实际使用分：
            1) 单列索引: CREATE INDEX index_addr ON tb_student(address(4)); => 索引只包含单个列
            2) 多列索引(复合索引、联合索引)：CREATE INDEX index_na ON tb_student(name,address); => 多个列共同组成, 只有出现第一个字段索引才能被用到
########################################################################################################################

########################################################################################################################
# 6、ref_or_null: 类似于ref, 但MySQL会额外搜索哪些行包含了NULL => 常见于子查询
    1) 查询(name是普通单列索引):
EXPLAIN
SELECT * FROM content WHERE name = '2' or name IS NULL;
    2)                  type
1	SIMPLE	content		ref_or_null	index_name	index_name	33	const	2	100	Using index condition
    3) 测试结果:
        => 1) 要有OR和IS NULL
        => 2) 索引类型要普通索引和唯一索引, 如果使用主键索引去测会得到const类型
########################################################################################################################

########################################################################################################################
# 7、index_merge: 表示使用了多种索引的合并
    1) 查询(id为主键, name为普通索引):
EXPLAIN
SELECT * FROM content WHERE id = 1 or name = '2';
    2)                  type
1	SIMPLE	content		index_merge	PRIMARY,index_name	PRIMARY,index_name	4,33		2	100	Using union(PRIMARY,index_name); Using where
########################################################################################################################

########################################################################################################################
8、unique_subquery: 没复现(不重要), 类似于eq_ref, 但外层查询使用了IN, 里层的子查询是主键或者是唯一索引 => 是一个索引查找函数, 可以完全替换掉子查询, 效率更高
########################################################################################################################

########################################################################################################################
9、index_subquery: 没复现(不重要), 类似于unique_subquery, 但里层的子查询是普通索引
########################################################################################################################

########################################################################################################################
10、range：范围扫描, 表示检索了指定范围的行 => 主要用于有限制的索引扫描, eg: >、>=、<=、IS NULL、<=>、BETWEEN、LIKE、IN()等
    1) 查询:
EXPLAIN
SELECT * FROM content WHERE id IN (1, 2);
    2)                  type
1	SIMPLE	content		range	PRIMARY	PRIMARY	4		2	100	Using index condition
    3) 测试结果:
        => 无论什么索引(指的是按逻辑区分的), 都可能会出现
        => 使用时, 如果匹配的值有一个和索引字段的类型不一致, 会从range退化成all
########################################################################################################################

########################################################################################################################
11、index：全索引扫描, 和all类似, 不过index是全盘扫描了索引中的数据, 只会遍历索引树 => 通常比all快
    1) 覆盖索引: SQL语句只通过索引就能取到了所需要的数据, 而不用回表中读取, 这个过程叫做索引覆盖, 那么对应查询出来的字段一定有索引, 索引被叫做覆盖索引
        => 覆盖索引必须存储列的值, 且在MySQL只能使用B树, 使用覆盖索引在Extra列会看到Using index的信息, 其他都代表没有完全进行索引覆盖
        https://blog.csdn.net/qq_15037231/article/details/87891683
        https://www.cnblogs.com/happyflyingpig/p/7662881.html
    2) 查询:
EXPLAIN
SELECT id FROM content;
    3)                  type
1	SIMPLE	content		index		index_name	33		3	100	Using index
    4) 测试结果:
        => 对多个索引一起查无效
        => 一般都会伴随Extra: Using index出现
########################################################################################################################

########################################################################################################################
12、all: 全表扫描, 性能最差
    1) 查询：
EXPLAIN
SELECT * FROM content;
    2)                  type
1	SIMPLE	content		ALL					3	100
########################################################################################################################










